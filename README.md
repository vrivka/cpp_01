# C++ - modules

C++ - modules серия задач для изучения различных аспектов языка C++ и ООП.

## Ссылки на другие модули

0. [CPP module 00](https://github.com/vrivka/cpp_00)
1. CPP module 01
2. [CPP module 02](https://github.com/vrivka/cpp_02)
3. [CPP module 03](https://github.com/vrivka/cpp_03)
4. [CPP module 04](https://github.com/vrivka/cpp_04)
5. [CPP module 05](https://github.com/vrivka/cpp_05)
6. [CPP module 06](https://github.com/vrivka/cpp_06)
7. [CPP module 07](https://github.com/vrivka/cpp_07)
8. [CPP module 08](https://github.com/vrivka/cpp_08)

# C++ - Module 01

## Описание модуля

Этот модуль разработан, чтобы помочь понять распределение памяти, ссылки, указатели на элементы и использование switch в C++.

## Задачи

### Exercise 00: BraiiiiiiinnnzzzZ

Реализовать класс `Zombie`. Он имеет `private` атрибут `std::string - name`. Добавить функцию-член `void announce(void);` к классу `Zombie`, которая выводит сообщение:
```
<name>: BraiiiiiiinnnzzzZ...
```

Затем реализовать следующие две функции:
```C++
Zombie* newZombie( std::string name );
```
Она создает `Zombie`, дает имя и возвращает его, чтобы была возможность использовать за пределами области действия функции.
```C++
void randomChump( std::string name );
```
Она создает `Zombie`, называет его, а затем `Zombie` объявит о себе.

В чем суть упражнения? Нужно определить, в каком случае лучше разместить `Zombie` в стеке или в куче.

`Zombie` должны быть уничтожены, когда они больше не нужны. Деструктор должен вывести сообщение с именем `Zombie` в целях отладки.

### Exercise 01: Moar brainz!

Реализовать функцию в соответствующем файле:
```C++
Zombie* zombieHorde( int N, std::string name );
```
Она должна выделить N объектов-`Zombie` за один раз. Затем она должна инициализировать зомби, дав каждому из них имя, переданное в качестве параметра. Функция возвращает указатель на первого зомби.

### Exercise 02: HI THIS IS BRAIN
Написать программу, которая содержит:
- `std::string`, инициализированная как `"HI THIS IS BRAIN"`.
- `stringPTR`: указатель на строку.
- `stringREF`: ссылка на строку.

Программа должна напечатать:
- Адрес памяти строковой переменной.
- Адрес памяти, удерживаемый `stringPTR`.
- Адрес памяти, удерживаемый `stringREF`.

Затем:
- Значение строковой переменной.
- Значение, на которое указывает `stringPTR`.
- Значение, на которое указывает `stringREF`.

Цель этого упражнения — понять разницу между указателями и ссылками, которые могут показаться совершенно новыми.

### Exercise 03: Unnecessary violence

Реализовать класс `Weapon`, который имеет:
- `private` атрибут `type`, представляющий собой строку.
- Функция-член `getType()`, возвращающая константную ссылку на `type`.
- Функция-член `setType()`, которая устанавливает `type`, используя новый `type`, переданный в качестве параметра.

Далее создать два класса: `HumanA` и `HumanB`. У них обоих есть `Weapon` и `name`. У них также есть функция `attack()`, которая отображает:
```
<name> attacks with their <weapon type>
```
`HumanA` и `HumanB` почти одинаковы, за исключением двух крошечных деталей:
- В то время как `HumanA` использует `Weapon` в своем конструкторе, `HumanB` — нет.
- `HumanB` не всегда может иметь оружие, тогда как `HumanA` всегда будет вооружен.

### Exercise 04: Sed is for losers

Написать программу, которая принимает три параметра в следующем порядке: имя файла и две строки, `s1` и `s2`.

Она откроет файл `<filename>` и скопирует его содержимое в новый файл `<filename>.replace`, заменив каждое вхождение `s1` на `s2`.

Использование функций манипулирования файлами из `C` запрещено. Разрешены все функции-члены класса `std::string`, кроме `replace`.

### Exercise 05: Karen 2.0

Ты знаешь Карен? Мы все знаем, не так ли? Если вы её не знаете, то найдете ниже комментарии, которые делает Карен. Они классифицируются по уровням:
- Уровень `DEBUG`: сообщения отладки содержат контекстную информацию. В основном они используются для диагностики проблем.
- Уровень `INFO`: Эти сообщения содержат обширную информацию. Они полезны для отслеживания выполнения программы в производственной среде.
- Уровень `WARNING`. Предупреждающие сообщения указывают на возможную проблему в системе. Однако с этим можно справиться или проигнорировать.
- Уровень `ОШИБКА`: Эти сообщения указывают на неустранимую ошибку. Обычно это критическая проблема, требующая ручного вмешательства.

Нужно создать класс `Karen` со следующими `private` функциями-членами:
```C++
void debug( void );
```
```C++
void info( void );
```
```C++
void warning( void );
```
```C++
void error( void );
```

У Карен также есть `public` функция-член, которая вызывает четыре указанные выше функции-члена в зависимости от уровня, переданного в качестве параметра:
```C++
void complain( std::string level );
```
Цель этого упражнения — использовать указатели на функции-члены. Карен приходится жаловаться, не используя лес `if`/`else if`/`else`. Она не думает дважды!

### Exercise 06: Karen filter

Иногда не хочется обращать внимание на все, что говорит Карен. Нужно внедрить систему для фильтрации того, что говорит Карен, в зависимости от уровней журнала, которые вы хотите прослушать.

Нужно создать программу, которая принимает в качестве параметра один из четырех уровней. И отобразить все сообщения с этого уровня и выше.

###### Навигация по модулям
[<<<<](https://github.com/vrivka/cpp_00)
[00](https://github.com/vrivka/cpp_00) |
01 |
[02](https://github.com/vrivka/cpp_02) |
[03](https://github.com/vrivka/cpp_03) |
[04](https://github.com/vrivka/cpp_04) |
[05](https://github.com/vrivka/cpp_05) |
[06](https://github.com/vrivka/cpp_06) |
[07](https://github.com/vrivka/cpp_07) |
[08](https://github.com/vrivka/cpp_08) |
[>>>>](https://github.com/vrivka/cpp_02)